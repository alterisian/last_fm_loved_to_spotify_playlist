<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libspotify: libspotify 0.0.4 API Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>libspotify 0.0.4 API Documentation </h1><p>This documentation explains how you can make use of the <em>libspotify</em> C API within an application of your own.</p>
<p>The documentation was generated with <a href="http://www.doxygen.org/">Doxygen</a>. You will find a list of submodules in the <a href="modules.html">Modules</a> section. The list of modules are ordered in a reasonable reading order. It begins with some <a href="group__types.html">simple types</a> used throughout the rest of the modules, continues with basic <a href="group__error.html">error handling</a> and the functions required to <a href="group__session.html">manage sessions</a>.</p>
<p>The rest of the modules are specfic parts of <em>libspotify</em> for accessing information about <a href="group__artistbrowse.html">artists</a>, <a href="group__albumbrowse.html">albums</a>, <a href="group__track.html">tracks</a>, and <a href="group__playlist.html">playlists</a>. Separate modules are available to handle <a href="group__search.html">searches</a> and <a href="group__image.html">images</a>.</p>
<p>This initial chapter of <em>libspotify</em> will focus on the general design of the library, and things to take into consideration once you start working with it.</p>
<p>For most of the functionality, there are <a href="examples.html">examples</a> available in <code>doc/examples</code>.</p>
<h2><a class="anchor" id="restr_sec">
Issues and Restrictions</a></h2>
<p>A few restrictions apply to the <em>libspotify</em> library. These may be changed (or fixed) in future versions of the library.</p>
<ul>
<li>Only one process can access the cache and settings directory. It is <em>your</em> responsibility to make sure instances of your application, or any other application and your application does not attempt to use the same cache. You can do this using a clever naming schema, or using a lock-file.</li>
<li>Even though <a class="el" href="group__session.html#gaa3d50584480c8a5b554ba5d1b8d09b8b">sp_session_init()</a> creates a new object, there are still some global variables behind the scenes that will stop you from creating multiple sessions within a single process. To avoid confusion, we have not included a sp_session_release() in this version. Thus the library will leak memory associated with the session. When the library supports multiple sessions correctly, a release function will be added.</li>
</ul>
<h2><a class="anchor" id="general_sec">
General Design</a></h2>
<p>In this section, you will find the overall philosophy of the library with regard to memory management and error handling.</p>
<h3><a class="anchor" id="err_sec">
Error Handling</a></h3>
<p>All functions that have some form of useful error state returns an <a class="el" href="group__error.html#gafd27986ce4cd9eeaeca8adda83c9eb6b">sp_error</a>. The actual result value is returned in an <code>out</code> pointer in these cases. Some functions return pointers where you must check for <code>NULL</code> before using the returned value. Those places should be documented next to each function.</p>
<p>In addition to functions returning an <a class="el" href="group__error.html#gafd27986ce4cd9eeaeca8adda83c9eb6b">sp_error</a>, some request objects (browse and search objects) have an error accessor. When the object has been loaded, the error code will be set to reflect the success or failure of the request.</p>
<p>A trivial <a class="el" href="group__error.html#ga983dee341d3c2008830513b7cffe7bf3">error code to string mapper function</a> exists that works just like <code>strerror(3)</code>.</p>
<h3><a class="anchor" id="refcnt_sec">
Reference Counting</a></h3>
<p>Reference counting is used for all domain objects in <em>libspotify</em>. Functions including the string <b>create</b> will return an object with a pre-incremented reference count. Thus, each <code>create</code> must have a corresponding <code>release</code> when the value is no longer needed.</p>
<p>Other accessor functions (including <a class="el" href="group__link.html#gab32979d26dcf68936202fa7aed7b6e49">sp_link_as_artist</a> et al.), on the other hand, returns a reference borrowed from the object it was retrieved from. Retrieving an <a class="el" href="group__types.html#ga6fd3e5de729c429fef3ff18ece6dcfad" title="An album handle.">sp_album</a> from an <a class="el" href="group__types.html#gaf90a23d6b662c96d52ac19f7f4bc1e39" title="A handle to the libspotify internal representation of a URI.">sp_link</a> would make the album object survive until the link object is freed, unless its reference count is explicitly incremented.</p>
<h3><a class="anchor" id="threads_sec">
Threads</a></h3>
<p>The library itself uses multiple threads internally. To allow for synchronization between these threads, you must implement the <a class="el" href="structsp__session__callbacks.html#a085cfd82e77aee2b592f314321019a29">sp_session_callbacks::notify_main_thread</a> callback. Whenever called (from some internal thread), the application must wake up the main loop so the <a class="el" href="group__session.html#ga019a640b351de2a1ffe040ed755013f4">sp_session_process_events()</a> function can be run.</p>
<p>The API itself is <em>not</em> thread-safe. Thus, you must take care not to call the API functions from more than one of your own threads.</p>
<h3><a class="anchor" id="objects_sec">
Objects</a></h3>
<p>All objects (tracks, albums, artists, etc) are loaded asynchronously. Therefore the API user must query the object via the _is_loaded() functions to check that the object data has been populated. There is currently no way of finding out when data has been updated for a specific object. Rather, the user need to iterate all objects of interest upon invokation of the metadata_updated() callback.</p>
<p>Also, objects are not populated when created as a result of a sp_link_as_...() method.</p>
<h3><a class="anchor" id="cache_sec">
Disk Cache Management</a></h3>
<p>Currently the disk cache can only be opened by one process at a time. It is preferrable not to put the cache in a network file system. To avoid clashes, we recommend you to put set the cache location to <code>/var/tmp/<em>username</em>/<em>appname</em>/</code> and to add some kind of lock. The <em>appname</em> would be a mangled user-agent string.</p>
<p>While you could simply remove the cache when the application exits to avoid the locking issue, your application will be slower as music, playlists and other metadata will have to be loaded from the server on each login. You are strongly encouraged to use a persistent cache.</p>
<p>Settings should be stored in the users home directory, but they should also be kept separate per application. We would recommend <code>~/.config/<em>appname</em>/libspotify/</code> for these files on UNIX-like systems or <code>%appdata%\<em>appname</em>\libspotify\</code> on Windows.</p>
<h2><a class="anchor" id="session_sec">
Session Management</a></h2>
<p>Before running any application you will need an <em>application key</em>. An application key allows Spotify to identify your application and should be unique per application. You will find more information about the application keys on our <a href="http://developer.spotify.com/">developer website</a>. We have choosen not to distribute the example programs with an application key, as that might cause the key to be misused. We encourage you to get a valid application key, and put it in a file called <code>appkey.c</code> and compile the examples using the included makefile.</p>
<p>In order to ensure all data is correctly synced to disk, we encourage you to actually use <a class="el" href="group__session.html#gab7f08ca0939985b30ae2d1ed9db1d726">sp_session_logout()</a> before terminating your application. Efter logout, you will receive a <a class="el" href="structsp__session__callbacks.html#a073231e9ceb3d40f4a772ab64ba4ece7">callback</a> call in which you could display a login box, or terminate.</p>
<h2><a class="anchor" id="image_sec">
Images</a></h2>
<p>Images are identified with a <code>const byte*</code> value, returned by various functions in the API (such as <a class="el" href="group__album.html#ga77cfa20fa7522c8be633389a5d1d0270">sp_album_cover()</a>). The pointers are valid until the object is freed, thus you should keep a reference to the objects until you are no longer using the image ID.</p>
<p>Images will always be given to the application as pixel buffers. The format, however, can vary depending on the platform and how <em>libspotify</em> handles the images internally.</p>
<p>The <a class="el" href="group__image.html#ga2cda19baf2460da5e81fb1917f54626b">sp_imageformat</a> type and <a class="el" href="group__image.html#ga04448e81ca4916ba7ed223d0d817e803">sp_image_format()</a> function should be used to at least assert the image format returned is what was expected. The geometry of images is available once the image has been loaded, and to get the pixel buffers, you call sp_image_lock_pixels() with a configurable pitch/stride. Remember to always unlock the pixel buffers once you are done.</p>
<h2><a class="anchor" id="audio_sec">
Audio</a></h2>
<p>The audio is delivered through a <a class="el" href="structsp__session__callbacks.html#a33a31478b8de1882ad7847ad033fbaeb">push-callback</a> called by <em>libspotify</em> when data is available. Your callback may eat all data, or just enough to fill some constant-sized buffer. The callback will be called from a libspotify internal thread, so if you share state between the audio callback and the main thread, be sure to add adequate thread synchronization.</p>
<p>Samples are delivered as integers, see <a class="el" href="structsp__audioformat.html">sp_audioformat</a>. One <em>frame</em> consists of the same number of samples as there are channels. I.e. interleaving is on the sample level.</p>
<h2><a class="anchor" id="examples_sec">
Examples</a></h2>
<p>Included in the distribution are a couple of example files designed to get you started easily.</p>
<h2><a class="anchor" id="license_sec">
Licenses</a></h2>
<p>The example code distributed with <em>libspotify</em> uses the <a href="http://www.opensource.org/licenses/mit-license.php">MIT license</a>. All documentation, <em>libspotify</em> itself, and the associated C header file are distributed under the libspotify <a href="http://developer.spotify.com/en/libspotify/terms-of-use/">Terms of Use</a>. </p>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Fri Apr 23 14:33:53 2010.<br>
Copyright &copy; 2006&ndash;2010 Spotify Ltd</small></address>
</body>
</html>
